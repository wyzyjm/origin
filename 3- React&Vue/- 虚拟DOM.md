# 虚拟 DOM

-   本质就是: React.createElement 创建的一个 js 对象来模拟 真实的 dom 节点, 包含 元素的标签,key, props 属性,children 等必要属性.
-   做了什么:

    -   首次加载将真实 dom 转化为虚拟 dom,
    -   更新的时候: 生成一个新的虚拟 dom, 利用 diff 算法去做对比.实际比较两个 js 对象, 然后找出差异点,局部更新视图,对比 直接操作 dom 浏览器性能, 这充其量是 js 执行效率的问题.

-   优势:

    -   减少 DOM 操作: 通过 diff 算法来实现差异化更新,来提高浏览器渲染性能.
    -   对内容进行了处理,对<>等进行了转义,防范 xss 攻击.
    -   可跨平台使用
        -   pc 网站: react + react-dom
        -   mo 网站: react + react-native

-   缺点:
    -   虚拟 dom 会消耗额外的内存.
    -   初次渲染的时候不一定会更快, 只是在更新的时候,可以实现精准的定向更新.

## diff 算法

-   实际上 React 维护了两个虚拟 dom, 一个是真实 dom 的副本,一个是具有更新状态的虚拟 DOM. 如何生成 dom 树更新补丁的方式.
-   `更新时机`: setState,以及 hook 调用之后
-   `优化策略`:
    -   树:
        -   忽略节点跨层级操作场景, 只对同一层节点做比较 ,如果发生跨层级移动是会直接创建的.
    -   组件:
        -   只要是同一类型组件,则继续对比同层级的子节点. shouldComponentUpdate 判断该组件是否需要进行 diff.
        -   如果类型不同则直接重新创建.
    -   元素:
        -   同一层级的所有子节点对比.提供了插入.移动.删除等操作.
        -   通过标记 key 的方式, react 可以直接移动 dom 节点.

## key 的作用

-   在同层级的一组子节点对比, 在 patch 过程中, diff 算法通过 key 来判断两个虚拟节点是否相同, 从而达到复用的目的
-   如果没有 key, 就会按照索引的顺序进行逐个对比了.

-   index 作为 key: 会出现内容错位的问题, 实际也没有对 diff 算法进行优化.

    -   当删除第二个节点, 第三个节点的 key 就成为了
    -   而 react diff 算法认为只要 key 相同就是同一个子节点, 实际不是同一个子节点.

    -   如果使用 索引 会导致 非受控组件内容相互篡改.
