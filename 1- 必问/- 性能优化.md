# 性能优化

-   `开场`:

    -   这是一个很大的话题, 它也是随着项目的推进,然后不断进行优化的.
    -   优化也不一定全是代码上的优化,还有有用户体验上的优化, 比如更新页面时,添加 loading 动画,或使用骨架屏.

-   `优化工具`

    -   传统网站可以通过 浏览器自带的 `lighthouse` 来分析页面情况. 它会出一个结果,包括页面 dom 加载,资源情况, 网站无障碍, seo 情况等. 然后有针对性的进行优化.
    -   单页面应用, 我用过 `source-map-explor`, 将打包后的项目 js 代码进行分析,看哪个文件比较大, 然后看看是不是可以按需引入等

-   `具体方案`

    -   `传统网站`:

        1. 加载优化

        -   css 优化

            -   将 css 写在头部, 因为 css 解析不会影响 dom 解析,是同步进行的.
            -   不写行内样式.
            -   不要使用@import 引用 css
            -   选择器尽量简单, 最多不要超过三层嵌套.

        -   js 优化
            -   js 加载阻塞 dom 加载, 因此放到页面底部, 再添加 async defer 属性.
        -   `静态资源本地化`:
            -   `强缓存` :cache-control
            -   `协商缓存`:服务端在返回资源的时候,设置响应头 Etag 和 last-modified, 如果命中协商缓存(max-age,cache-cotrol), 就不会发送请求,如果没有命中,则发送请求,如果文件没有被修改,则返回 304, 如果修改了,则返回最新的.

        1. 图片优化

            - 精灵图, 又叫雪碧图, 将多个图标合成一个图片, 然后通过背景图的方式展示,使用 background-position 来展示. svg 替代
            - 小图片使用 base64
            - 图片懒加载, 在看不到的时候不展示,当图片出现在页面中时,再给图片 src 赋值.
            - 给图片设置多个档位,根据不同分辨率来请求不同大小的图片.

        2. 渲染优化

            - 减少重排. 动画脱离文档流, 位置移动使用 transform 而不是 left, top.

    -   `SPA 应用主要是首屏加载的优化`

        -   `让用户尽早的看到网站内容`: 使用 loading 动画, 或者 骨架屏.
        -   减少入口文件体积:

            -   常用的手段就是路由懒加载, 把不同路由对应的组件分割成不同的代码块. 待路由被请求时会单独打包路由.
            -   Vue: 箭头函数的形式 import 组件, React 可以使用 lazy 方法来引用组件.

        -   第三方依赖包:`按需加载`
        -   `React`
            -   类组件:
                -   大部分情况下创建组件时可以 继承 `PureComponent`, `它实现了shouldComponentUpdate`的浅层比较.
                -   在 `shouldConentUpdate` 里面判断 当前 state 与接下来的 props,state 是否相同,来避免不必要的渲染.
            -   函数式组件: 通过 `Memo` 包裹组件 来实现组件的缓存.
            -   组件编写的时候,属性值尽量抽取成一个变量.
            -   然后就是 `useMemo` 和 `useCallback` 的使用.
        -   `webpack`
            -   使用 resolve.alias 指定路径别名, ts 是在 tsconfig 中配置,然后在 webpack 中使用 `tsconfig-path-webapck-plugin`
            -   缩小构建目标, 在配置 `loader` 的时候, `exclude:/node_modules/`将 node_modules 排除.
            -   线上环境开启 gzip, `compression-webpack-plugin`
            -   缓存某些被使用多次的公共文件. 指定被使用的次数.
